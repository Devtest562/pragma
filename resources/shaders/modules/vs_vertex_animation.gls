#ifndef F_VS_VERTEX_ANIMATION_GLS
#define F_VS_VERTEX_ANIMATION_GLS

#ifndef SHADER_UNIFORM_VERTEX_ANIMATION_SET
    #define SHADER_UNIFORM_VERTEX_ANIMATION_SET 0
    #define SHADER_UNIFORM_VERTEX_ANIMATION_BINDING 0
#endif

#ifndef SHADER_UNIFORM_VERTEX_ANIMATION_FRAME_DATA_SET
    #define SHADER_UNIFORM_VERTEX_ANIMATION_FRAME_DATA_SET SHADER_UNIFORM_VERTEX_ANIMATION_SET
    #define SHADER_UNIFORM_VERTEX_ANIMATION_FRAME_DATA_BINDING (SHADER_UNIFORM_VERTEX_ANIMATION_BINDING +1)
#endif

#include "/math/half_float.gls"

layout(std430,LAYOUT_ID(SHADER_UNIFORM_VERTEX_ANIMATION_SET,SHADER_UNIFORM_VERTEX_ANIMATION_BINDING)) buffer VertexAnimation {
	ivec4 verts[];
} vertexAnimation;

void get_vertex_anim_vertex_position(uint frameOffset,out vec3 vpos,out vec3 vnorm,out float vwrinkle)
{
	uvec4 v = vertexAnimation.verts[frameOffset +SH_VERTEX_INDEX];
	vpos = vec3(
		float16_to_float(int(v[0]>>16)),
		float16_to_float(int((v[0]<<16)>>16)),
		float16_to_float(int(v[1]>>16))
	);
	vwrinkle = float16_to_float(int((v[1]<<16)>>16));
	vnorm = vec3(
		float16_to_float(int(v[2]>>16)),
		float16_to_float(int((v[2]<<16)>>16)),
		float16_to_float(int(v[3]>>16))
	);
}

struct VertexAnimationFrameData
{
    uint srcFrameOffset;
    uint dstFrameOffset;
    float blend;
    float padding;
};
layout(std430,LAYOUT_ID(SHADER_UNIFORM_VERTEX_ANIMATION_FRAME_DATA_SET,SHADER_UNIFORM_VERTEX_ANIMATION_FRAME_DATA_BINDING)) buffer VAFrameData {
	VertexAnimationFrameData data[];
} vaFrameData;

#endif
