#ifndef F_VS_WORLD_GLS
#define F_VS_WORLD_GLS

#include "vs_weighted.gls"
#include "vs_buffer_locations.gls"
#include "sh_vertex_data.gls"
#include "sh_normalmapping.gls"
#include "sh_parallaxmapping.gls"
#include "sh_vertex_data.gls"
#include "sh_material.gls"

#include "../functions/sh_vector_to_depth.gls"
#include "../lighting/sh_lighting.gls"
#include "../modules/sh_csm.gls"
#include "../modules/sh_rendersettings.gls"
#include "../modules/sh_camera_info.gls"
#include "../modules/sh_math.gls"
#include "../modules/vs_vertex_animation.gls"
#include "../modules/light_map/vs_lightmap.gls"
#include "../modules/vs_instanced_entity_data.gls"

layout(location = SHADER_VERTEX_BUFFER_LOCATION) in vec3 in_vert_pos;
layout(location = SHADER_UV_BUFFER_LOCATION) in vec2 in_vert_uv;
layout(location = SHADER_NORMAL_BUFFER_LOCATION) in vec3 in_vert_normal;

#include "vs_light.gls"

void export_world_fragment_data(mat4 mdlMatrix,vec3 vertPos)
{
	uint vertexAnimOffset = (u_pushConstants.vertexAnimInfo<<16)>>16;
	uint vertexAnimCount = u_pushConstants.vertexAnimInfo>>16;
	float wrinkleDelta = 0.0;
	vec3 vertNorm = in_vert_normal.xyz;
	for(uint i=0;i<vertexAnimCount;++i)
	{
		uint offset = vertexAnimOffset +i;
		VertexAnimationFrameData frameData = vaFrameData.data[offset];

		vec3 vpos0;
		vec3 vnorm0;
		float vwrinkle0;
		get_vertex_anim_vertex_position(frameData.srcFrameOffset,vpos0,vnorm0,vwrinkle0);

		vec3 vpos1;
		vec3 vnorm1;
		float vwrinkle1;
		get_vertex_anim_vertex_position(frameData.srcFrameOffset,vpos1,vnorm1,vwrinkle1);

		wrinkleDelta += vwrinkle0 *frameData.blend;
		vertPos += vpos0 *frameData.blend;//v0 +(v1 -v0) *frameData.blend;
		vertNorm += vnorm0 *frameData.blend;
	}
	vertNorm = normalize(vertNorm);

	vs_out.wrinkleDelta = wrinkleDelta;

	//mat4 MV = V *mdlMatrix;
	//mat4 MVP = u_camera.P *MV;

	mat4 mBone = calc_bone_matrix(is_instanced_weighted(),is_weighted_ext());
	vec4 weightedVertPos = mBone *vec4(vertPos,1.0);

	vec4 vposWs = mdlMatrix *weightedVertPos;
	if(is_3d_sky())
	{
		vposWs.xyz -= u_pushConstants.drawOrigin.xyz;
		vposWs.xyz *= u_pushConstants.drawOrigin.w;
	}

	mat4 V = get_view_matrix();
	gl_Position = API_DEPTH_TRANSFORM(u_camera.P) *V *vposWs;

	vposWs.xyz /= vposWs.w;
	vposWs.w = 1.0;

	if(length_sqr(u_pushConstants.clipPlane.xyz) > 0.0)
		gl_ClipDistance[0] = dot(vec4(vposWs.xyz,1.0),u_pushConstants.clipPlane);
	else
		gl_ClipDistance[0] = 1.0;

	vec3 normal = normalize((mBone *vec4(vertNorm.xyz,0.0)).xyz);
	
	vs_out.vert_pos_ws = vposWs.xyz;
	vs_out.M = get_instanced_model_matrix();
	vs_out.color = get_instanced_instance_color();
	//vs_out.vert_pos = vertPos;
	//vs_out.vert_pos_cs = (V *vposWs).xyz;

	vs_out.vert_normal = normal;
	vs_out.vert_normal_cs = (V *mdlMatrix *vec4(normal,0)).xyz;
	
	vs_out.vert_uv = in_vert_uv.xy;

   vec3 T = normalize((mBone *vec4(in_vert_tangent,0.0)).xyz);
   vec3 B = normalize((mBone *vec4(in_vert_bitangent,0.0)).xyz);
   vec3 N = normal;
   vs_out.TBN = mat3(T,B,N);

#if ENABLE_LIGHTMAP == 1
	if(is_light_map_enabled())
		vs_out.vert_uv_lightmap.xy = in_uv_lightmap;
#endif

	// Parallax Mapping
	/*if(use_parallax_map() == true) // We only need these if parallax mapping is enabled
	{
		vec3 tangent = normalize((mBone *vec4(-in_vert_tangent,0.0)).xyz);
		vec3 bitangent = normalize((mBone *vec4(in_vert_bitangent,0.0)).xyz);
		mat3 TBN = transpose(mat3(
			normalize((mdlMatrix *vec4(tangent,0.0)).xyz),
			normalize((mdlMatrix *vec4(bitangent,0.0)).xyz),
			normalize((mdlMatrix *vec4(normal,0.0)).xyz)
		));
		vec3 camPosTs = TBN *u_renderSettings.posCam;
		vec3 vertPosTs = TBN *vs_out.vert_pos_ws.xyz;

		vs_out.tangentData.cam_dir_to_vert_ts = camPosTs -vertPosTs;
	}*/
	//

	export_light_fragment_data(vposWs,mBone,normal,mdlMatrix);
	//export_light_fragment_data(vposWs,mBone,normal,MV);
}

void export_world_fragment_data(vec3 vertPos) {export_world_fragment_data(get_instanced_model_matrix(),vertPos);}

void export_world_fragment_data() {export_world_fragment_data(in_vert_pos.xyz);}

#endif
