#ifndef F_FS_PBR_LIGHTING_LIGHT_SPOT_GLS
#define F_FS_PBR_LIGHTING_LIGHT_SPOT_GLS

#include "light_shared.gls"
#include "/lighting/fs_lighting_spot.gls"

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float get_spot_attenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)
{
	float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));
	if (actualCos > outerConeCos)
	{
		if (actualCos < innerConeCos)
			return smoothstep(outerConeCos, innerConeCos, actualCos);
		return 1.0;
	}
	return 0.0;
}

vec3 apply_spot_light(LightSourceData light, uint lightIndex, MaterialInfo materialInfo, vec3 normal, vec3 view)
{
	vec3 pointToLight = light.position.xyz - fs_in.vert_pos_ws.xyz;
	float distance = length(pointToLight);
	float rangeAttenuation = calc_light_falloff(distance,light.position.w);
	rangeAttenuation = pow(rangeAttenuation,light.falloffExponent);
	float spotAttenuation = get_spot_attenuation(pointToLight, light.direction.xyz, cos(light.cutoffOuter), cos(light.cutoffInner));
	vec3 shade = get_point_shade(pointToLight, materialInfo, normal, view);

	float shadowFactor = are_shadows_enabled() ? min(
		get_spot_light_shadow_factor(lightIndex,false), // static sample
		get_spot_light_shadow_factor(lightIndex,true) // dynamic sample
	) : 1.0;
	return rangeAttenuation * spotAttenuation * light.color.a * light.color.rgb *shade *shadowFactor;
}

#endif
