#ifndef F_FS_PBR_GLS
#define F_FS_PBR_GLS

#define ENABLE_LIGHT_DEBUG 1
#ifndef DEBUG_MODE
	#define DEBUG_MODE DEBUG_MODE_NONE
#endif

#include "lighting.gls"
#include "/modules/sh_parallaxmapping.gls"
#include "/modules/fs_tonemapping.gls"
#include "/modules/fs_scene.gls"
#include "/modules/fs_glowmap.gls"
#include "/modules/fs_renderer.gls"
#include "/debug/fs_debug_csm.gls"
#include "debug.gls"

vec4 calc_pbr(vec4 albedoColor,vec2 texCoords,uint debugMode)
{
	// Metallic and Roughness material properties are packed together
	// In glTF, these factors can be specified by fixed scalar values
	// or from a metallic-roughness map
	float perceptualRoughness = 0.0;
	float metallic = 0.0;
	vec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);
	vec3 diffuseColor = vec3(0.0);
	vec3 specularColor= vec3(0.0);
	vec3 f0 = vec3(0.04);

#if 0
	baseColor = texture(u_albedoMap,texCoords);
	if(u_srgb)
		baseColor = srgb_to_linear(baseColor);
	baseColor *= u_DiffuseFactor;
#endif

	// f0 = specular
	specularColor = f0;
	float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);
	diffuseColor = baseColor.rgb * oneMinusSpecularStrength;

	vec4 rma = texture(u_rmaMap,texCoords);
	perceptualRoughness = rma[RMA_CHANNEL_ROUGHNESS] * 1.0;

	// Glossiness
	// TODO
	//vec4 glossiness = texture(u_specularMap,texCoords);
	//perceptualRoughness *= (1.0 -glossiness.r); // Glossiness to roughness

	perceptualRoughness *= u_material.roughnessFactor;

	metallic = rma[RMA_CHANNEL_METALNESS] * u_material.metalnessFactor;

	vec4 colorMod = get_instance_color();
	baseColor = albedoColor;
	baseColor.a = apply_alpha_mode(baseColor.a *colorMod.a *u_material.color.a,u_material.alphaMode,u_material.alphaCutoff);
	baseColor.rgb *= colorMod.rgb *u_material.color.rgb;

	if(fs_in.wrinkleDelta != 0.0)
	{
		float wrinkle = clamp(-fs_in.wrinkleDelta,0,1);
		float stretch = clamp(fs_in.wrinkleDelta,0,1);
		float baseColorFactor = 1.0 -wrinkle -stretch;

		vec4 wrinkleCol = texture(u_wrinkleCompressMap,texCoords);
		vec4 stretchCol = texture(u_wrinkleStretchMap,texCoords);

		baseColor.rgb = baseColorFactor *baseColor.rgb +wrinkle *wrinkleCol.rgb +stretch *stretchCol.rgb;
	}


	if(true)//is_diffuse_srgb()) // TODO
		baseColor.rgb = srgb_to_linear(baseColor.rgb);
	//baseColor *= u_DiffuseFactor;
	diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);
	specularColor = mix(f0, baseColor.rgb, metallic);

	perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);
	metallic = clamp(metallic, 0.0, 1.0);

	// Roughness is authored as perceptual roughness; as is convention,
	// convert to material roughness by squaring the perceptual roughness [2].
	float alphaRoughness = perceptualRoughness * perceptualRoughness;

	// Compute reflectance.
	float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

	vec3 specularEnvironmentR0 = specularColor.rgb;
	// Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to "Real-Time-Rendering" 4th editon on page 325.
	vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));

	float aoFactor = u_material.aoFactor;
	MaterialInfo materialInfo = MaterialInfo(
		perceptualRoughness,
		specularEnvironmentR0,
		alphaRoughness,
		diffuseColor,
		specularEnvironmentR90,
		specularColor,
		aoFactor
	);

	// Lighting
	vec3 color = calc_pbr_lighting(texCoords,materialInfo,baseColor);

	if((u_debug.flags &DEBUG_FORWARD_PLUS_HEATMAP) != 0)
	{
		ivec2 location = ivec2(gl_FragCoord.xy);
		uint tileSize = get_tile_size();
		ivec2 tileID = location /ivec2(tileSize,tileSize);
		uint index = tileID.y *get_number_of_tiles_x() +tileID.x;
		uint offset = index *MAX_SCENE_LIGHTS;
		uint numLights = 0;
		for (uint i = 0; i < MAX_SCENE_LIGHTS && visibleLightTileIndicesBuffer.data[offset + i].index != -1; i++)
		{
			uint lightIndex = visibleLightTileIndicesBuffer.data[offset + i].index;
			LightSourceData light = get_light_source(int(lightIndex));
			if((light.flags &FLIGHT_TYPE_DIRECTIONAL) == 0)
				++numLights;
		}
		if(numLights > 0)
		{
			const float dbgIntensity = 0.95;
			color.rgb = (vec3(tileID.x /float(tileSize),tileID.y /float(tileSize),0) *(numLights /float(5))) *pow(1.0,dbgIntensity *1.0)
					+color.rgb *(1.0 -dbgIntensity);
		}
	}

	// regular shading
	vec4 result = vec4(color.rgb, baseColor.a); // TODO

	if(use_glow_map())
	{
		vec4 emissiveColor = texture(u_glowMap,texCoords);
		if(true)//is_glow_srgb()) // TODO
			emissiveColor.rgb = srgb_to_linear(emissiveColor.rgb);
		emissiveColor.rgb *= u_material.emissionFactor.rgb;
		result = add_glow_color(result,texCoords,emissiveColor,baseColor);
	}

	result = apply_debug_mode(debugMode,result,texCoords,diffuseColor,metallic,perceptualRoughness,aoFactor,reflectance);
	return result;
}

#endif
