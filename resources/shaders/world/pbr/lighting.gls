#ifndef F_FS_PBR_LIGHTING_GLS
#define F_FS_PBR_LIGHTING_GLS

#include "material.gls"
#include "normal.gls"
#include "lighting/ibl.gls"
#include "lighting/light_spot.gls"
#include "lighting/light_point.gls"
#include "lighting/light_directional.gls"
#include "/modules/fs_renderer.gls"
#include "/modules/sh_entity_info.gls"
#include "/modules/sh_instance_info.gls"
#include "/modules/light_map/fs_lightmap.gls"
#include "/modules/fs_ssao.gls"

vec3 calc_pbr_lighting(vec2 uv,MaterialInfo materialInfo,vec4 baseColor)
{
    if(is_unlit() == true)
        return baseColor.rgb;
    vec3 color = vec3(0.0, 0.0, 0.0);

    vec3 normal = get_normal_from_map(uv);
    normal = normalize((get_model_matrix() *vec4(normal.xyz,0.0)).xyz);

    vec3 view = normalize(u_renderSettings.posCam - fs_in.vert_pos_ws.xyz);

    bool useLightmaps = is_light_map_enabled();
    if(useLightmaps)
    {
        vec4 colLightMap = texture(u_lightMap,fs_in.vert_uv_lightmap.xy);
        //baseColor.rgb *= colLightMap.rgb;
        color = baseColor.rgb;
    }
    /*else */if(is_ibl_enabled())
       color += get_ibl_contribution(materialInfo, normal, view);

    if(useLightmaps)
    {
		vec4 colLightMap = texture(u_lightMap,fs_in.vert_uv_lightmap.xy);
		color.rgb = color.rgb *(u_renderSettings.lightmapExposurePow *colLightMap.rgb);
    }

    ivec2 location = ivec2(gl_FragCoord.xy);
    uint tileSize = get_tile_size();
    ivec2 tileID = location /ivec2(tileSize,tileSize);
    uint index = tileID.y *get_number_of_tiles_x() +tileID.x;
    uint offset = index *MAX_SCENE_LIGHTS;
    for(uint i=0; i < MAX_SCENE_LIGHTS && visibleLightTileIndicesBuffer.data[offset + i].index != -1; i++)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
            continue;
        if((light.flags &FLIGHT_TYPE_SPOT) != 0)
            color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        else if((light.flags &FLIGHT_TYPE_POINT) != 0)
            color += apply_point_light(light,lightIndex,materialInfo,normal,view);
        else
            color += apply_directional_light(light,lightIndex,materialInfo,normal,view);
    }

    // TODO
    vec4 rma = texture(u_rmaMap,uv);
    float ao = rma[RMA_CHANNEL_AO];

    // TODO
    if(is_ssao_enabled() == true)
        ao *= get_ssao_occlusion(get_viewport_width(),get_viewport_height()); // TODO: Disable ssao if ao map exists?

    // Apply optional PBR terms for additional (optional) shading
    color = mix(color, color * ao, materialInfo.aoFactor *0.7 +0.3);

    return color;
}

#endif
