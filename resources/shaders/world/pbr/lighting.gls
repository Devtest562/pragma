#ifndef F_FS_PBR_LIGHTING_GLS
#define F_FS_PBR_LIGHTING_GLS

#include "material.gls"
#include "normal.gls"
#include "lighting/ibl.gls"
#include "lighting/light_spot.gls"
#include "lighting/light_point.gls"
#include "lighting/light_directional.gls"
#include "/modules/fs_renderer.gls"
#include "/modules/sh_entity_info.gls"
#include "/modules/sh_instance_info.gls"
#include "/modules/light_map/fs_lightmap.gls"
#include "/modules/fs_ssao.gls"

vec3 apply_lighting(LightSourceData light,uint lightIndex,MaterialInfo materialInfo,vec3 normal,vec3 view)
{
    return ((light.flags &FLIGHT_TYPE_SPOT) == 0) ? apply_spot_light(light,lightIndex,materialInfo,normal,view) : apply_point_light(light,lightIndex,materialInfo,normal,view);
}

vec3 calc_pbr_lighting(vec2 uv,MaterialInfo materialInfo,vec4 baseColor)
{
    vec3 color = vec3(0.0, 0.0, 0.0);

    vec3 normal = get_normal_from_map(uv);
    normal = normalize((get_model_matrix() *vec4(normal.xyz,0.0)).xyz);

    vec3 view = normalize(u_renderSettings.posCam - fs_in.vert_pos_ws.xyz);

    bool useLightmaps = false;
    if(CSPEC_ENABLE_LIGHT_MAPS == 1)
    {
        useLightmaps = is_light_map_enabled();
        if(useLightmaps)
        {
            vec4 colLightMap = texture(u_lightMap,fs_in.vert_uv_lightmap.xy);
            //baseColor.rgb *= colLightMap.rgb;
            color = baseColor.rgb;
        }
    }
    if(CSPEC_ENABLE_IBL == 1)
    {
        /*else */if(is_ibl_enabled())
           color += get_ibl_contribution(materialInfo, normal, view);
    }

    if(CSPEC_ENABLE_LIGHT_MAPS == 1)
    {
        if(useLightmaps)
        {
    		vec4 colLightMap = texture(u_lightMap,fs_in.vert_uv_lightmap.xy);
    		color.rgb = color.rgb *(get_lightmap_exposure_pow() *colLightMap.rgb);
        }
    }

    ivec2 location = ivec2(gl_FragCoord.xy);
    uint tileSize = get_tile_size();
    ivec2 tileID = location /ivec2(tileSize,tileSize);
    uint index = tileID.y *get_number_of_tiles_x() +tileID.x;
    uint tileStartOffset = index *MAX_SCENE_LIGHTS;
#if 0
    for(uint i=0;i<visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_SPOT_LIGHT_BUFFER_START].index;++i)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_SPOT_LIGHT_BUFFER_START +i +1].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
    }
    for(uint i=0;i<visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_POINT_LIGHT_BUFFER_START].index;++i)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_POINT_LIGHT_BUFFER_START +i +1].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_point_light(light,lightIndex,materialInfo,normal,view);
    }
    for(uint i=0;i<visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_DIRECTIONAL_LIGHT_BUFFER_START].index;++i)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_DIRECTIONAL_LIGHT_BUFFER_START +i +1].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_directional_light(light,lightIndex,materialInfo,normal,view);
    }
#else

    if(CSPEC_ENABLE_LIGHT_SOURCES == 1)
    {
        if(CSPEC_ENABLE_LIGHT_SOURCES_SPOT == 1)
        {
            for(uint i=SCENE_SPOT_LIGHT_BUFFER_START; i < SCENE_SPOT_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[tileStartOffset + i].index != -1; i++)
            {
                uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +i].index;
                LightSourceData light = get_light_source(lightIndex);
                //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
                //    continue;
                color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
            }
        }
        if(CSPEC_ENABLE_LIGHT_SOURCES_POINT == 1)
        {
            for(uint i=SCENE_POINT_LIGHT_BUFFER_START; i < SCENE_POINT_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[tileStartOffset + i].index != -1; i++)
            {
                uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +i].index;
                LightSourceData light = get_light_source(lightIndex);
                //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
                //    continue;
                color += apply_point_light(light,lightIndex,materialInfo,normal,view);
            }
        }
        if(CSPEC_ENABLE_LIGHT_SOURCES_DIRECTIONAL == 1)
        {
            for(uint i=SCENE_DIRECTIONAL_LIGHT_BUFFER_START; i < SCENE_DIRECTIONAL_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[tileStartOffset + i].index != -1; i++)
            {
                uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +i].index;
                LightSourceData light = get_light_source(lightIndex);
                //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
                //    continue;
                color += apply_directional_light(light,lightIndex,materialInfo,normal,view);
            }
        }
    }
#endif
    /*for(uint i=SCENE_SPOT_LIGHT_BUFFER_START; i < 10; i++)
    {
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }*/
    //for(uint i=SCENE_SPOT_LIGHT_BUFFER_START; i < 5 && visibleLightTileIndicesBuffer.data[offset + i].index != -1; i++)
   /* {
        uint i = 0;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 1;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 2;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 3;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 4;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 5;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 6;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 7;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 8;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 9;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }*/
    /*for(uint i=SCENE_POINT_LIGHT_BUFFER_START; i < SCENE_POINT_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[offset + i].index != -1; i++)
    {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_point_light(light,lightIndex,materialInfo,normal,view);
    }
    for(uint i=SCENE_DIRECTIONAL_LIGHT_BUFFER_START; i < SCENE_DIRECTIONAL_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[offset + i].index != -1; i++)
    {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_directional_light(light,lightIndex,materialInfo,normal,view);
    }*/
    return color;
}

#endif
