#ifndef F_FS_PBR_LIGHTING_GLS
#define F_FS_PBR_LIGHTING_GLS

#include "material.gls"
#include "normal.gls"
#include "lighting/ibl.gls"
#include "lighting/light_spot.gls"
#include "lighting/light_point.gls"
#include "lighting/light_directional.gls"
#include "/modules/fs_renderer.gls"
#include "/modules/sh_entity_info.gls"
#include "/modules/sh_instance_info.gls"
#include "/modules/light_map/fs_lightmap.gls"
#include "/modules/fs_ssao.gls"

vec3 apply_lighting(LightSourceData light,uint lightIndex,MaterialInfo materialInfo,vec3 normal,vec3 view)
{
    return ((light.flags &FLIGHT_TYPE_SPOT) == 0) ? apply_spot_light(light,lightIndex,materialInfo,normal,view) : apply_point_light(light,lightIndex,materialInfo,normal,view);
}

vec3 calc_pbr_lighting(vec2 uv,MaterialInfo materialInfo,vec4 baseColor)
{
    if(is_unlit() == true)
        return baseColor.rgb;
    vec3 color = vec3(0.0, 0.0, 0.0);

    vec3 normal = get_normal_from_map(uv);
    normal = normalize((get_model_matrix() *vec4(normal.xyz,0.0)).xyz);

    vec3 view = normalize(u_renderSettings.posCam - fs_in.vert_pos_ws.xyz);

    bool useLightmaps = is_light_map_enabled();
    if(useLightmaps)
    {
        vec4 colLightMap = texture(u_lightMap,fs_in.vert_uv_lightmap.xy);
        //baseColor.rgb *= colLightMap.rgb;
        color = baseColor.rgb;
    }
    /*else */if(is_ibl_enabled())
       color += get_ibl_contribution(materialInfo, normal, view);

    if(useLightmaps)
    {
		vec4 colLightMap = texture(u_lightMap,fs_in.vert_uv_lightmap.xy);
		color.rgb = color.rgb *(get_lightmap_exposure_pow() *colLightMap.rgb);
    }

    ivec2 location = ivec2(gl_FragCoord.xy);
    uint tileSize = get_tile_size();
    ivec2 tileID = location /ivec2(tileSize,tileSize);
    uint index = tileID.y *get_number_of_tiles_x() +tileID.x;
    uint tileStartOffset = index *MAX_SCENE_LIGHTS;
#if 0
    for(uint i=0;i<visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_SPOT_LIGHT_BUFFER_START].index;++i)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_SPOT_LIGHT_BUFFER_START +i +1].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
    }
    for(uint i=0;i<visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_POINT_LIGHT_BUFFER_START].index;++i)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_POINT_LIGHT_BUFFER_START +i +1].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_point_light(light,lightIndex,materialInfo,normal,view);
    }
    for(uint i=0;i<visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_DIRECTIONAL_LIGHT_BUFFER_START].index;++i)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +SCENE_DIRECTIONAL_LIGHT_BUFFER_START +i +1].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_directional_light(light,lightIndex,materialInfo,normal,view);
    }
#else
    for(uint i=SCENE_SPOT_LIGHT_BUFFER_START; i < SCENE_SPOT_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[tileStartOffset + i].index != -1; i++)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
    }
    for(uint i=SCENE_POINT_LIGHT_BUFFER_START; i < SCENE_POINT_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[tileStartOffset + i].index != -1; i++)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_point_light(light,lightIndex,materialInfo,normal,view);
    }
    for(uint i=SCENE_DIRECTIONAL_LIGHT_BUFFER_START; i < SCENE_DIRECTIONAL_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[tileStartOffset + i].index != -1; i++)
    {
        uint lightIndex = visibleLightTileIndicesBuffer.data[tileStartOffset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_directional_light(light,lightIndex,materialInfo,normal,view);
    }
#endif
    /*for(uint i=SCENE_SPOT_LIGHT_BUFFER_START; i < 10; i++)
    {
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }*/
    //for(uint i=SCENE_SPOT_LIGHT_BUFFER_START; i < 5 && visibleLightTileIndicesBuffer.data[offset + i].index != -1; i++)
   /* {
        uint i = 0;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 1;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 2;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 3;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 4;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 5;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 6;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 7;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 8;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }
    {
        uint i = 9;
        if(visibleLightTileIndicesBuffer.data[offset + i].index != -1)
        {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_spot_light(light,lightIndex,materialInfo,normal,view);
        }
    }*/
    /*for(uint i=SCENE_POINT_LIGHT_BUFFER_START; i < SCENE_POINT_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[offset + i].index != -1; i++)
    {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_point_light(light,lightIndex,materialInfo,normal,view);
    }
    for(uint i=SCENE_DIRECTIONAL_LIGHT_BUFFER_START; i < SCENE_DIRECTIONAL_LIGHT_BUFFER_END && visibleLightTileIndicesBuffer.data[offset + i].index != -1; i++)
    {
        uint lightIndex = 0;//visibleLightTileIndicesBuffer.data[offset +i].index;
        LightSourceData light = get_light_source(lightIndex);
        //if(useLightmaps == true && (light.flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
        //    continue;
        color += apply_directional_light(light,lightIndex,materialInfo,normal,view);
    }*/

    // TODO
    vec4 rma = texture(u_rmaMap,uv);
    float ao = rma[RMA_CHANNEL_AO];

    // TODO
    if(is_ssao_enabled() == true)
        ao *= get_ssao_occlusion(get_viewport_width(),get_viewport_height()); // TODO: Disable ssao if ao map exists?

    // Apply optional PBR terms for additional (optional) shading
    color = mix(color, color * ao, materialInfo.aoFactor *0.7 +0.3);

    return color;
}

#endif
